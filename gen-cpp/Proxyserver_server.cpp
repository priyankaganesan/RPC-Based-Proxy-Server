// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Proxyserver.h"
#include "../Caches/LRU_cache.h"
//#include "../Caches/fifo.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <string.h>
#include <iostream>
#include <cstring>
#include <curl/curl.h>
#include <sys/select.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace std;

using boost::shared_ptr;

using namespace  ::Test;


 struct MemoryStruct {
    char *memory;
    size_t size;
 };

LRU_cache cache;

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)
{
  size_t realsize = size * nmemb;
  MemoryStruct *mem = (MemoryStruct *)userp;
 
  mem->memory = (char*) realloc(mem->memory, mem->size + realsize + 1);
  if(mem->memory == NULL) {
    /* out of memory! */ 
    printf("not enough memory (realloc returned NULL)\n");
    return 0;
  }
 
  memcpy(&(mem->memory[mem->size]), contents, realsize);
  mem->size += realsize;
  mem->memory[mem->size] = 0;
 
  return realsize;
}



class ProxyserverHandler : virtual public ProxyserverIf {
 public:
  ProxyserverHandler() {
    // Your initialization goes here
  }

  void request(Response& _return, const std::string& url) {



//    fifo cache;
    string data;

    /* Respose codes
    ) 
    0 - LibCurl FAIL!!!! :P
    1 - HIT in cache
    2 _ MISS in cache - Inserted successfully
    3  "      " - Unsuccessful insertion


    */

    cout<<endl<<url;

    if(cache.access_cache(url,data))
    {
      _return.doc=data;
      _return.response_code=1;
      return;
    }


    CURL *curl_handle;
    CURLcode res;
    MemoryStruct chunk;
      /* Get a curl handle.  Each thread will need a unique handle. */
    curl_handle = curl_easy_init();
    if(NULL != curl_handle) {
      chunk.memory = (char*) malloc(1024);  /* will be grown as needed by the realloc above */ 
      chunk.size = 0;    /* no data at this point */ 
      /*Allow redirection*/
      curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
      /*Timeout for connections, in seconds*/
      curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 30L);
      /* Set the URL for the operation. */
      curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());
      /* "write_data" function to call with returned data. */
      curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
      /* userp parameter passed to write_data. */
      curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
      /* Actually perform the query. */
      res = curl_easy_perform(curl_handle);
      /* Check the return value and do whatever. */

      /* Clean up after ourselves. */
      curl_easy_cleanup(curl_handle);
 //     cout<<chunk.memory;
    }
    else {
      fprintf(stderr, "Error: could not get CURL handle.\n");
      exit(EXIT_FAILURE);
    }

//     Write the content to stdout. 
//    curl_return.assign(wdi.data, wdi.len);
    if(res==0)
    {
      data.assign(chunk.memory,chunk.size);
      
      if(cache.insert(url,data))
      {
        _return.response_code=2;
        _return.doc=data;
      }
      else
      {
        _return.response_code=3;
        _return.doc="a";
      }
    }
    else
    {
      _return.doc="";
      _return.response_code=0;
      return;
    }

    free(chunk.memory);
  
}

  void shutdown() {
    // Your implementation goes here
    printf("shutdown\n");
  }


};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<ProxyserverHandler> handler(new ProxyserverHandler());
  shared_ptr<TProcessor> processor(new ProxyserverProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

